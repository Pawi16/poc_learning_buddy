[
  {
    "title": "Creating and Destroying Objects T",
    "content": "HIS chapter concerns creating and destroying objects: when and how to create\nthem, when and how to avoid creating them, how to ensure they are destroyed in a\ntimely manner, and how to manage any cleanup actions that must precede their\ndestruction.\nItem 1: Consider static factory methods instead of constructors\nThe traditional way for a class to allow a client to obtain an instance is to provide\na public constructor. There is another technique that should be a part of every\nprogrammer’s toolkit. A class can provide a public static factory method , which is\nsimply a static method that returns an instance of the class. Here’s a simple\nexample from Boolean (the boxed primitive class for boolean ). This method\ntranslates a boolean primitive value into a Boolean object reference:\npublic static Boolean valueOf(boolean b) {\nreturn b ? Boolean.TRUE : Boolean.FALSE;\n}\nNote that a static factory method is not the same as the Factory Method pattern\nfrom Design Patterns [Gamma95]. The static factory method described in this\nitem has no direct equivalent in Design Patterns .\nA class can provide its clients with static factory methods instead of, or in\naddition to, public constructors. Providing a static factory method instead of a\npublic constructor has both advantages and disadvantages.\nOne advantage of static factory methods is that, unlike constructors, they\nhave names. If the parameters to a constructor do not, in and of themselves,\ndescribe the object being returned, a static factory with a well-chosen name is\neasier to use and the resulting client code easier to read. For example, the\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 6",
    "content": "constructor BigInteger(int, int, Random) , which returns a BigInteger that is\nprobably prime, would have been better expressed as a static factory method\nnamed BigInteger.probablePrime . (This method was added in Java 4.)\nA class can have only a single constructor with a given signature. Program-\nmers have been known to get around this restriction by providing two constructors\nwhose parameter lists differ only in the order of their parameter types. This is a\nreally bad idea. The user of such an API will never be able to remember which\nconstructor is which and will end up calling the wrong one by mistake. People\nreading code that uses these constructors will not know what the code does\nwithout referring to the class documentation.\nBecause they have names, static factory methods don’t share the restriction\ndiscussed in the previous paragraph. In cases where a class seems to require\nmultiple constructors with the same signature, replace the constructors with static\nfactory methods and carefully chosen names to highlight their differences.\nA second advantage of static factory methods is that, unlike constructors,\nthey are not required to create a new object each time they’re invoked. This\nallows immutable classes (Item17) to use preconstructed instances, or to cache\ninstances as they’re constructed, and dispense them repeatedly to avoid creating\nunnecessary duplicate objects. The Boolean.valueOf(boolean) method illus-\ntrates this technique: it never creates an object. This technique is similar to the\nFlyweight pattern [Gamma95]. It can greatly improve performance if equivalent\nobjects are requested often, especially if they are expensive to create.\nThe ability of static factory methods to return the same object from repeated\ninvocations allows classes to maintain strict control over what instances exist at\nany time. Classes that do this are said to be instance-controlled. There are several\nreasons to write instance-controlled classes. Instance control allows a class to guar-\nantee that it is a singleton (Item3) or noninstantiable (Item4). Also, it allows an\nimmutable value class (Item17) to make the guarantee that no two equal instances\nexist: a.equals(b) if and only if a == b . This is the basis of the Flyweight pattern\n[Gamma95]. Enum types (Item34) provide this guarantee.\nA third advantage of static factory methods is that, unlike constructors,\nthey can return an object of any subtype of their return type. This gives you\ngreat flexibility in choosing the class of the returned object.\nOne application of this flexibility is that an API can return objects without\nmaking their classes public. Hiding implementation classes in this fashion leads to\na very compact API. This technique lends itself to interface-based frameworks\n(Item20), where interfaces provide natural return types for static factory methods.\n"
  },
  {
    "title": "ITEM 1: CONSIDER STATIC FACTORY METHODS INSTEAD OF CONSTRUCTORS 7",
    "content": "Prior to Java 8, interfaces couldn’t have static methods. By convention, static\nfactory methods for an interface named Type were put in a noninstantiable com-\npanion class (Item4) named Types . For example, the Java Collections Framework\nhas forty-five utility implementations of its interfaces, providing unmodifiable\ncollections, synchronized collections, and the like. Nearly all of these implemen-\ntations are exported via static factory methods in one noninstantiable class\n( java.util.Collections ). The classes of the returned objects are all nonpublic.\nThe Collections Framework API is much smaller than it would have been had\nit exported forty-five separate public classes, one for each convenience implemen-\ntation. It is not just the bulk of the API that is reduced but the conceptual weight:\nthe number and difficulty of the concepts that programmers must master in order\nto use the API. The programmer knows that the returned object has precisely the\nAPI specified by its interface, so there is no need to read additional class docu-\nmentation for the implementation class. Furthermore, using such a static factory\nmethod requires the client to refer to the returned object by interface rather than\nimplementation class, which is generally good practice (Item64).\nAs of Java 8, the restriction that interfaces cannot contain static methods was\neliminated, so there is typically little reason to provide a noninstantiable compan-\nion class for an interface. Many public static members that would have been at\nhome in such a class should instead be put in the interface itself. Note, however,\nthat it may still be necessary to put the bulk of the implementation code behind\nthese static methods in a separate package-private class. This is because Java 8\nrequires all static members of an interface to be public. Java 9 allows private static\nmethods, but static fields and static member classes are still required to be public.\nA fourth advantage of static factories is that the class of the returned\nobject can vary from call to call as a function of the input parameters. Any sub-\ntype of the declared return type is permissible. The class of the returned object can\nalso vary from release to release.\nThe EnumSet class (Item36) has no public constructors, only static factories.\nIn the OpenJDK implementation, they return an instance of one of two subclasses,\ndepending on the size of the underlying enum type: if it has sixty-four or fewer\nelements, as most enum types do, the static factories return a RegularEnumSet\ninstance, which is backed by a single long ; if the enum type has sixty-five or more\nelements, the factories return a JumboEnumSet instance, backed by a long array.\nThe existence of these two implementation classes is invisible to clients. If\nRegularEnumSet ceased to offer performance advantages for small enum types, it\ncould be eliminated from a future release with no ill effects. Similarly, a future\nrelease could add a third or fourth implementation of EnumSet if it proved beneficial\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 8",
    "content": "for performance. Clients neither know nor care about the class of the object they get\nback from the factory; they care only that it is some subclass of EnumSet .\nA fifth advantage of static factories is that the class of the returned object\nneed not exist when the class containing the method is written. Such flexible\nstatic factory methods form the basis of service provider frameworks , like the Java\nDatabase Connectivity API (JDBC). A service provider framework is a system in\nwhich providers implement a service, and the system makes the implementations\navailable to clients, decoupling the clients from the implementations.\nThere are three essential components in a service provider framework: a\nservice interface , which represents an implementation; a provider registration\nAPI , which providers use to register implementations; and a service access API ,\nwhich clients use to obtain instances of the service. The service access API may\nallow clients to specify criteria for choosing an implementation. In the absence of\nsuch criteria, the API returns an instance of a default implementation, or allows\nthe client to cycle through all available implementations. The service access API\nis the flexible static factory that forms the basis of the service provider framework.\nAn optional fourth component of a service provider framework is a service\nprovider interface , which describes a factory object that produce instances of the\nservice interface. In the absence of a service provider interface, implementations\nmust be instantiated reflectively (Item65). In the case of JDBC, Connection\nplays the part of the service interface, DriverManager.registerDriver is the\nprovider registration API, DriverManager.getConnection is the service access\nAPI, and Driver is the service provider interface.\nThere are many variants of the service provider framework pattern. For exam-\nple, the service access API can return a richer service interface to clients than the\none furnished by providers. This is the Bridge pattern [Gamma95]. Dependency\ninjection frameworks (Item5) can be viewed as powerful service providers. Since\nJava 6, the platform includes a general-purpose service provider framework,\njava.util.ServiceLoader , so you needn’t, and generally shouldn’t, write your\nown (Item59). JDBC doesn’t use ServiceLoader , as the former predates the latter.\nThe main limitation of providing only static factory methods is that\nclasses without public or protected constructors cannot be subclassed. For\nexample, it is impossible to subclass any of the convenience implementation\nclasses in the Collections Framework. Arguably this can be a blessing in disguise\nbecause it encourages programmers to use composition instead of inheritance\n(Item18), and is required for immutable types (Item17).\nA second shortcoming of static factory methods is that they are hard for\nprogrammers to find. They do not stand out in API documentation in the way\n"
  },
  {
    "title": "ITEM 1: CONSIDER STATIC FACTORY METHODS INSTEAD OF CONSTRUCTORS 9",
    "content": "that constructors do, so it can be difficult to figure out how to instantiate a class\nthat provides static factory methods instead of constructors. The Javadoc tool may\nsomeday draw attention to static factory methods. In the meantime, you can\nreduce this problem by drawing attention to static factories in class or interface\ndocumentation and by adhering to common naming conventions. Here are some\ncommon names for static factory methods. This list is far from exhaustive:\nfrom —A type-conversion method that takes a single parameter and returns a\ncorresponding instance of this type, for example:\nDate d = Date.from(instant);\nof —An aggregation method that takes multiple parameters and returns an in-\nstance of this type that incorporates them, for example:\nSet<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);\nvalueOf —A more verbose alternative to from and of , for example:\nBigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);\ninstance or getInstance —Returns an instance that is described by its pa-\nrameters (if any) but cannot be said to have the same value, for example:\nStackWalker luke = StackWalker.getInstance(options);\ncreate or newInstance —Like instance or getInstance , except that the\nmethod guarantees that each call returns a new instance, for example:\nObject newArray = Array.newInstance(classObject, arrayLen);\nget Type —Like getInstance , but used if the factory method is in a different\nclass. Type is the type of object returned by the factory method, for example:\nFileStore fs = Files.getFileStore(path);\nnew Type —Like newInstance , but used if the factory method is in a different\nclass. Type is the type of object returned by the factory method, for example:\nBufferedReader br = Files.newBufferedReader(path);\ntype —A concise alternative to get Type and new Type , for example:\nList<Complaint> litany = Collections.list(legacyLitany);\nIn summary, static factory methods and public constructors both have their\nuses, and it pays to understand their relative merits. Often static factories are\npreferable, so avoid the reflex to provide public constructors without first consid-\nering static factories.\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 10",
    "content": "Item 2: Consider a builder when faced with many constructor\nparameters\nStatic factories and constructors share a limitation: they do not scale well to large\nnumbers of optional parameters. Consider the case of a class representing the\nNutrition Facts label that appears on packaged foods. These labels have a few\nrequired fields—serving size, servings per container, and calories per serving—\nand more than twenty optional fields—total fat, saturated fat, trans fat, cholesterol,\nsodium, and so on. Most products have nonzero values for only a few of these\noptional fields.\nWhat sort of constructors or static factories should you write for such a class?\nTraditionally, programmers have used the telescoping constructor pattern, in\nwhich you provide a constructor with only the required parameters, another with a\nsingle optional parameter, a third with two optional parameters, and so on, culmi-\nnating in a constructor with all the optional parameters. Here’s how it looks in\npractice. For brevity’s sake, only four optional fields are shown:\n// Telescoping constructor pattern - does not scale well!\npublic class NutritionFacts {\nprivate final int servingSize; // (mL) required\nprivate final int servings; // (per container) required\nprivate final int calories; // (per serving) optional\nprivate final int fat; // (g/serving) optional\nprivate final int sodium; // (mg/serving) optional\nprivate final int carbohydrate; // (g/serving) optional\npublic NutritionFacts(int servingSize, int servings) {\nthis(servingSize, servings, 0);\n}\npublic NutritionFacts(int servingSize, int servings,\nint calories) {\nthis(servingSize, servings, calories, 0);\n}\npublic NutritionFacts(int servingSize, int servings,\nint calories, int fat) {\nthis(servingSize, servings, calories, fat, 0);\n}\npublic NutritionFacts(int servingSize, int servings,\nint calories, int fat, int sodium) {\nthis(servingSize, servings, calories, fat, sodium, 0);\n}\n"
  },
  {
    "title": "ITEM 2: CONSIDER A BUILDER WHEN FACED WITH MANY CONSTRUCTOR PARAMETERS 11",
    "content": "public NutritionFacts(int servingSize, int servings,\nint calories, int fat, int sodium, int carbohydrate) {\nthis.servingSize = servingSize;\nthis.servings = servings;\nthis.calories = calories;\nthis.fat = fat;\nthis.sodium = sodium;\nthis.carbohydrate = carbohydrate;\n}\n}\nWhen you want to create an instance, you use the constructor with the shortest\nparameter list containing all the parameters you want to set:\nNutritionFacts cocaCola =\nnew NutritionFacts(240, 8, 100, 0, 35, 27);\nTypically this constructor invocation will require many parameters that you don’t\nwant to set, but you’re forced to pass a value for them anyway. In this case, we\npassed a value of 0 for fat . With “only” six parameters this may not seem so bad,\nbut it quickly gets out of hand as the number of parameters increases.\nIn short, the telescoping constructor pattern works, but it is hard to write\nclient code when there are many parameters, and harder still to read it. The\nreader is left wondering what all those values mean and must carefully count\nparameters to find out. Long sequences of identically typed parameters can cause\nsubtle bugs. If the client accidentally reverses two such parameters, the compiler\nwon’t complain, but the program will misbehave at runtime (Item51).\nA second alternative when you’re faced with many optional parameters in a\nconstructor is the JavaBeans pattern, in which you call a parameterless construc-\ntor to create the object and then call setter methods to set each required parameter\nand each optional parameter of interest:\n// JavaBeans Pattern - allows inconsistency, mandates mutability\npublic class NutritionFacts {\n// Parameters initialized to default values (if any)\nprivate int servingSize = -1; // Required; no default value\nprivate int servings = -1; // Required; no default value\nprivate int calories = 0;\nprivate int fat = 0;\nprivate int sodium = 0;\nprivate int carbohydrate = 0;\npublic NutritionFacts() { }\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 12",
    "content": "// Setters\npublic void setServingSize(int val) { servingSize = val; }\npublic void setServings(int val) { servings = val; }\npublic void setCalories(int val) { calories = val; }\npublic void setFat(int val) { fat = val; }\npublic void setSodium(int val) { sodium = val; }\npublic void setCarbohydrate(int val) { carbohydrate = val; }\n}\nThis pattern has none of the disadvantages of the telescoping constructor pattern.\nIt is easy, if a bit wordy, to create instances, and easy to read the resulting code:\nNutritionFacts cocaCola = new NutritionFacts();\ncocaCola.setServingSize(240);\ncocaCola.setServings(8);\ncocaCola.setCalories(100);\ncocaCola.setSodium(35);\ncocaCola.setCarbohydrate(27);\nUnfortunately, the JavaBeans pattern has serious disadvantages of its own.\nBecause construction is split across multiple calls, a JavaBean may be in an\ninconsistent state partway through its construction. The class does not have\nthe option of enforcing consistency merely by checking the validity of the\nconstructor parameters. Attempting to use an object when it’s in an inconsistent\nstate may cause failures that are far removed from the code containing the bug and\nhence difficult to debug. A related disadvantage is that the JavaBeans pattern\nprecludes the possibility of making a class immutable (Item17) and requires\nadded effort on the part of the programmer to ensure thread safety.\nIt is possible to reduce these disadvantages by manually “freezing” the object\nwhen its construction is complete and not allowing it to be used until frozen, but\nthis variant is unwieldy and rarely used in practice. Moreover, it can cause errors\nat runtime because the compiler cannot ensure that the programmer calls the\nfreeze method on an object before using it.\nLuckily, there is a third alternative that combines the safety of the telescoping\nconstructor pattern with the readability of the JavaBeans pattern. It is a form of the\nBuilder pattern [Gamma95]. Instead of making the desired object directly, the\nclient calls a constructor (or static factory) with all of the required parameters and\ngets a builder object . Then the client calls setter-like methods on the builder object\nto set each optional parameter of interest. Finally, the client calls a parameterless\nbuild method to generate the object, which is typically immutable. The builder is\ntypically a static member class (Item24) of the class it builds. Here’s how it looks\nin practice:\n"
  },
  {
    "title": "ITEM 2: CONSIDER A BUILDER WHEN FACED WITH MANY CONSTRUCTOR PARAMETERS 13",
    "content": "// Builder Pattern\npublic class NutritionFacts {\nprivate final int servingSize;\nprivate final int servings;\nprivate final int calories;\nprivate final int fat;\nprivate final int sodium;\nprivate final int carbohydrate;\npublic static class Builder {\n// Required parameters\nprivate final int servingSize;\nprivate final int servings;\n// Optional parameters - initialized to default values\nprivate int calories = 0;\nprivate int fat = 0;\nprivate int sodium = 0;\nprivate int carbohydrate = 0;\npublic Builder(int servingSize, int servings) {\nthis.servingSize = servingSize;\nthis.servings = servings;\n}\npublic Builder calories(int val)\n{ calories = val; return this; }\npublic Builder fat(int val)\n{ fat = val; return this; }\npublic Builder sodium(int val)\n{ sodium = val; return this; }\npublic Builder carbohydrate(int val)\n{ carbohydrate = val; return this; }\npublic NutritionFacts build() {\nreturn new NutritionFacts(this);\n}\n}\nprivate NutritionFacts(Builder builder) {\nservingSize = builder.servingSize;\nservings = builder.servings;\ncalories = builder.calories;\nfat = builder.fat;\nsodium = builder.sodium;\ncarbohydrate = builder.carbohydrate;\n}\n}\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 14",
    "content": "The NutritionFacts class is immutable, and all parameter default values are\nin one place. The builder’s setter methods return the builder itself so that invoca-\ntions can be chained, resulting in a fluent API . Here’s how the client code looks:\nNutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n.calories(100).sodium(35).carbohydrate(27).build();\nThis client code is easy to write and, more importantly, easy to read. The Builder\npattern simulates named optional parameters as found in Python and Scala.\nValidity checks were omitted for brevity. To detect invalid parameters as soon\nas possible, check parameter validity in the builder’s constructor and methods.\nCheck invariants involving multiple parameters in the constructor invoked by the\nbuild method. To ensure these invariants against attack, do the checks on object\nfields after copying parameters from the builder (Item50). If a check fails, throw\nan IllegalArgumentException (Item72) whose detail message indicates which\nparameters are invalid (Item75).\nThe Builder pattern is well suited to class hierarchies. Use a parallel hier-\narchy of builders, each nested in the corresponding class. Abstract classes have\nabstract builders; concrete classes have concrete builders. For example, consider\nan abstract class at the root of a hierarchy representing various kinds of pizza:\n// Builder pattern for class hierarchies\npublic abstract class Pizza {\npublic enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }\nfinal Set<Topping> toppings;\nabstract static class Builder<T extends Builder<T>> {\nEnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);\npublic T addTopping(Topping topping) {\ntoppings.add(Objects.requireNonNull(topping));\nreturn self();\n}\nabstract Pizza build();\n// Subclasses must override this method to return \"this\"\nprotected abstract T self();\n}\nPizza(Builder<?> builder) {\ntoppings = builder.toppings.clone(); // See Item 50\n}\n}\nNote that Pizza.Builder is a generic type with a recursive type parameter\n(Item30). This, along with the abstract self method, allows method chaining to\nwork properly in subclasses, without the need for casts. This workaround for the\nfact that Java lacks a self type is known as the simulated self-type idiom.\n"
  },
  {
    "title": "ITEM 2: CONSIDER A BUILDER WHEN FACED WITH MANY CONSTRUCTOR PARAMETERS 15",
    "content": "Here are two concrete subclasses of Pizza , one of which represents a standard\nNew-York-style pizza, the other a calzone. The former has a required size parame-\nter, while the latter lets you specify whether sauce should be inside or out:\npublic class NyPizza extends Pizza {\npublic enum Size { SMALL, MEDIUM, LARGE }\nprivate final Size size;\npublic static class Builder extends Pizza.Builder<Builder> {\nprivate final Size size;\npublic Builder(Size size) {\nthis.size = Objects.requireNonNull(size);\n}\n@Override public NyPizza build() {\nreturn new NyPizza(this);\n}\n@Override protected Builder self() { return this; }\n}\nprivate NyPizza(Builder builder) {\nsuper(builder);\nsize = builder.size;\n}\n}\npublic class Calzone extends Pizza {\nprivate final boolean sauceInside;\npublic static class Builder extends Pizza.Builder<Builder> {\nprivate boolean sauceInside = false; // Default\npublic Builder sauceInside() {\nsauceInside = true;\nreturn this;\n}\n@Override public Calzone build() {\nreturn new Calzone(this);\n}\n@Override protected Builder self() { return this; }\n}\nprivate Calzone(Builder builder) {\nsuper(builder);\nsauceInside = builder.sauceInside;\n}\n}\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 16",
    "content": "Note that the build method in each subclass’s builder is declared to return the\ncorrect subclass: the build method of NyPizza.Builder returns NyPizza , while\nthe one in Calzone.Builder returns Calzone . This technique, wherein a subclass\nmethod is declared to return a subtype of the return type declared in the super-\nclass, is known as covariant return typing . It allows clients to use these builders\nwithout the need for casting.\nThe client code for these “hierarchical builders” is essentially identical to the\ncode for the simple NutritionFacts builder. The example client code shown next\nassumes static imports on enum constants for brevity:\nNyPizza pizza = new NyPizza.Builder(SMALL)\n.addTopping(SAUSAGE).addTopping(ONION).build();\nCalzone calzone = new Calzone.Builder()\n.addTopping(HAM).sauceInside().build();\nA minor advantage of builders over constructors is that builders can have mul-\ntiple varargs parameters because each parameter is specified in its own method.\nAlternatively, builders can aggregate the parameters passed into multiple calls to a\nmethod into a single field, as demonstrated in the addTopping method earlier.\nThe Builder pattern is quite flexible. A single builder can be used repeatedly\nto build multiple objects. The parameters of the builder can be tweaked between\ninvocations of the build method to vary the objects that are created. A builder can\nfill in some fields automatically upon object creation, such as a serial number that\nincreases each time an object is created.\nThe Builder pattern has disadvantages as well. In order to create an object, you\nmust first create its builder. While the cost of creating this builder is unlikely to be\nnoticeable in practice, it could be a problem in performance-critical situations.\nAlso, the Builder pattern is more verbose than the telescoping constructor pattern,\nso it should be used only if there are enough parameters to make it worthwhile, say\nfour or more. But keep in mind that you may want to add more parameters in the\nfuture. But if you start out with constructors or static factories and switch to a\nbuilder when the class evolves to the point where the number of parameters gets\nout of hand, the obsolete constructors or static factories will stick out like a sore\nthumb. Therefore, it’s often better to start with a builder in the first place.\nIn summary, the Builder pattern is a good choice when designing classes\nwhose constructors or static factories would have more than a handful of\nparameters , especially if many of the parameters are optional or of identical type.\nClient code is much easier to read and write with builders than with telescoping\nconstructors, and builders are much safer than JavaBeans.\n"
  },
  {
    "title": "ITEM 3: ENFORCE THE SINGLETON PROPERTY WITH A PRIVATE CONSTRUCTOR OR AN ENUM TYPE 17",
    "content": "Item 3: Enforce the singleton property with a private\nconstructor or an enum type\nA singleton is simply a class that is instantiated exactly once [Gamma95]. Single-\ntons typically represent either a stateless object such as a function (Item24) or a\nsystem component that is intrinsically unique. Making a class a singleton can\nmake it difficult to test its clients because it’s impossible to substitute a mock\nimplementation for a singleton unless it implements an interface that serves as its\ntype.\nThere are two common ways to implement singletons. Both are based on\nkeeping the constructor private and exporting a public static member to provide\naccess to the sole instance. In one approach, the member is a final field:\n// Singleton with public final field\npublic class Elvis {\npublic static final Elvis INSTANCE = new Elvis();\nprivate Elvis() { ... }\npublic void leaveTheBuilding() { ... }\n}\nThe private constructor is called only once, to initialize the public static final\nfield Elvis.INSTANCE . The lack of a public or protected constructor guarantees a\n“monoelvistic” universe: exactly one Elvis instance will exist once the Elvis\nclass is initialized—no more, no less. Nothing that a client does can change this,\nwith one caveat: a privileged client can invoke the private constructor reflectively\n(Item65) with the aid of the AccessibleObject.setAccessible method. If you\nneed to defend against this attack, modify the constructor to make it throw an\nexception if it’s asked to create a second instance.\nIn the second approach to implementing singletons, the public member is a\nstatic factory method:\n// Singleton with static factory\npublic class Elvis {\nprivate static final Elvis INSTANCE = new Elvis();\nprivate Elvis() { ... }\npublic static Elvis getInstance() { return INSTANCE; }\npublic void leaveTheBuilding() { ... }\n}\nAll calls to Elvis.getInstance return the same object reference, and no other\nElvis instance will ever be created (with the same caveat mentioned earlier).\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 18",
    "content": "The main advantage of the public field approach is that the API makes it clear\nthat the class is a singleton: the public static field is final, so it will always contain\nthe same object reference. The second advantage is that it’s simpler.\nOne advantage of the static factory approach is that it gives you the flexibility\nto change your mind about whether the class is a singleton without changing its\nAPI. The factory method returns the sole instance, but it could be modified to\nreturn, say, a separate instance for each thread that invokes it. A second advantage\nis that you can write a generic singleton factory if your application requires it\n(Item30). A final advantage of using a static factory is that a method reference can\nbe used as a supplier, for example Elvis::instance is a Supplier<Elvis> .\nUnless one of these advantages is relevant, the public field approach is preferable.\nTo make a singleton class that uses either of these approaches serializable\n(Chapter 12), it is not sufficient merely to add implements Serializable to its\ndeclaration. To maintain the singleton guarantee, declare all instance fields\ntransient and provide a readResolve method (Item89). Otherwise, each time a\nserialized instance is deserialized, a new instance will be created, leading, in the\ncase of our example, to spurious Elvis sightings. To prevent this from happening,\nadd this readResolve method to the Elvis class:\n// readResolve method to preserve singleton property\nprivate Object readResolve() {\n// Return the one true Elvis and let the garbage collector\n// take care of the Elvis impersonator.\nreturn INSTANCE;\n}\nA third way to implement a singleton is to declare a single-element enum:\n// Enum singleton - the preferred approach\npublic enum Elvis {\nINSTANCE;\npublic void leaveTheBuilding() { ... }\n}\nThis approach is similar to the public field approach, but it is more concise,\nprovides the serialization machinery for free, and provides an ironclad guarantee\nagainst multiple instantiation, even in the face of sophisticated serialization or\nreflection attacks. This approach may feel a bit unnatural, but a single-element\nenum type is often the best way to implement a singleton . Note that you can’t\nuse this approach if your singleton must extend a superclass other than Enum\n(though you can declare an enum to implement interfaces).\n"
  },
  {
    "title": "ITEM 4: ENFORCE NONINSTANTIABILITY WITH A PRIVATE CONSTRUCTOR 19",
    "content": "Item 4: Enforce noninstantiability with a private constructor\nOccasionally you’ll want to write a class that is just a grouping of static methods\nand static fields. Such classes have acquired a bad reputation because some people\nabuse them to avoid thinking in terms of objects, but they do have valid uses. They\ncan be used to group related methods on primitive values or arrays, in the manner\nof java.lang.Math or java.util.Arrays . They can also be used to group static\nmethods, including factories (Item1), for objects that implement some interface,\nin the manner of java.util.Collections . (As of Java 8, you can also put such\nmethods in the interface, assuming it’s yours to modify.) Lastly, such classes can\nbe used to group methods on a final class, since you can’t put them in a subclass.\nSuch utility classes were not designed to be instantiated: an instance would be\nnonsensical. In the absence of explicit constructors, however, the compiler pro-\nvides a public, parameterless default constructor . To a user, this constructor is\nindistinguishable from any other. It is not uncommon to see unintentionally\ninstantiable classes in published APIs.\nAttempting to enforce noninstantiability by making a class abstract does\nnot work. The class can be subclassed and the subclass instantiated. Furthermore,\nit misleads the user into thinking the class was designed for inheritance (Item19).\nThere is, however, a simple idiom to ensure noninstantiability. A default construc-\ntor is generated only if a class contains no explicit constructors, so a class can be\nmade noninstantiable by including a private constructor :\n// Noninstantiable utility class\npublic class UtilityClass {\n// Suppress default constructor for noninstantiability\nprivate UtilityClass() {\nthrow new AssertionError();\n}\n... // Remainder omitted\n}\nBecause the explicit constructor is private, it is inaccessible outside the class.\nThe AssertionError isn’t strictly required, but it provides insurance in case the\nconstructor is accidentally invoked from within the class. It guarantees the class\nwill never be instantiated under any circumstances. This idiom is mildly counter-\nintuitive because the constructor is provided expressly so that it cannot be\ninvoked. It is therefore wise to include a comment, as shown earlier.\nAs a side effect, this idiom also prevents the class from being subclassed. All\nconstructors must invoke a superclass constructor, explicitly or implicitly, and a\nsubclass would have no accessible superclass constructor to invoke.\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 20",
    "content": "Item 5: Prefer dependency injection to hardwiring resources\nMany classes depend on one or more underlying resources. For example, a spell\nchecker depends on a dictionary. It is not uncommon to see such classes imple-\nmented as static utility classes (Item4):\n// Inappropriate use of static utility - inflexible & untestable!\npublic class SpellChecker {\nprivate static final Lexicon dictionary = ...;\nprivate SpellChecker() {} // Noninstantiable\npublic static boolean isValid(String word) { ... }\npublic static List<String> suggestions(String typo) { ... }\n}\nSimilarly, it’s not uncommon to see them implemented as singletons (Item3):\n// Inappropriate use of singleton - inflexible & untestable!\npublic class SpellChecker {\nprivate final Lexicon dictionary = ...;\nprivate SpellChecker(...) {}\npublic static INSTANCE = new SpellChecker(...);\npublic boolean isValid(String word) { ... }\npublic List<String> suggestions(String typo) { ... }\n}\nNeither of these approaches is satisfactory, because they assume that there is\nonly one dictionary worth using. In practice, each language has its own dictionary,\nand special dictionaries are used for special vocabularies. Also, it may be\ndesirable to use a special dictionary for testing. It is wishful thinking to assume\nthat a single dictionary will suffice for all time.\nYou could try to have SpellChecker support multiple dictionaries by making\nthe dictionary field nonfinal and adding a method to change the dictionary in an\nexisting spell checker, but this would be awkward, error-prone, and unworkable in\na concurrent setting. Static utility classes and singletons are inappropriate for\nclasses whose behavior is parameterized by an underlying resource.\nWhat is required is the ability to support multiple instances of the class (in our\nexample, SpellChecker ), each of which uses the resource desired by the client (in\nour example, the dictionary). A simple pattern that satisfies this requirement is to\npass the resource into the constructor when creating a new instance . This is\none form of dependency injection : the dictionary is a dependency of the spell\nchecker and is injected into the spell checker when it is created.\n"
  },
  {
    "title": "ITEM 5: PREFER DEPENDENCY INJECTION TO HARDWIRING RESOURCES 21",
    "content": "// Dependency injection provides flexibility and testability\npublic class SpellChecker {\nprivate final Lexicon dictionary;\npublic SpellChecker(Lexicon dictionary) {\nthis.dictionary = Objects.requireNonNull(dictionary);\n}\npublic boolean isValid(String word) { ... }\npublic List<String> suggestions(String typo) { ... }\n}\nThe dependency injection pattern is so simple that many programmers use it\nfor years without knowing it has a name. While our spell checker example had\nonly a single resource (the dictionary), dependency injection works with an\narbitrary number of resources and arbitrary dependency graphs. It preserves\nimmutability (Item17), so multiple clients can share dependent objects (assuming\nthe clients desire the same underlying resources). Dependency injection is equally\napplicable to constructors, static factories (Item1), and builders (Item2).\nA useful variant of the pattern is to pass a resource factory to the constructor.\nA factory is an object that can be called repeatedly to create instances of a type.\nSuch factories embody the Factory Method pattern [Gamma95]. The\nSupplier<T> interface, introduced in Java 8, is perfect for representing factories.\nMethods that take a Supplier<T> on input should typically constrain the factory’s\ntype parameter using a bounded wildcard type (Item31) to allow the client to pass\nin a factory that creates any subtype of a specified type. For example, here is a\nmethod that makes a mosaic using a client-provided factory to produce each tile:\nMosaic create(Supplier<? extends Tile> tileFactory) { ... }\nAlthough dependency injection greatly improves flexibility and testability, it\ncan clutter up large projects, which typically contain thousands of dependencies.\nThis clutter can be all but eliminated by using a dependency injection framework ,\nsuch as Dagger [Dagger], Guice [Guice], or Spring [Spring]. The use of these\nframeworks is beyond the scope of this book, but note that APIs designed for\nmanual dependency injection are trivially adapted for use by these frameworks.\nIn summary, do not use a singleton or static utility class to implement a class\nthat depends on one or more underlying resources whose behavior affects that of\nthe class, and do not have the class create these resources directly. Instead, pass\nthe resources, or factories to create them, into the constructor (or static factory or\nbuilder). This practice, known as dependency injection, will greatly enhance the\nflexibility, reusability, and testability of a class.\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 22",
    "content": "Item 6: Avoid creating unnecessary objects\nIt is often appropriate to reuse a single object instead of creating a new function-\nally equivalent object each time it is needed. Reuse can be both faster and more\nstylish. An object can always be reused if it is immutable (Item17).\nAs an extreme example of what not to do, consider this statement:\nString s = new String(\"bikini\"); // DON'T DO THIS!\nThe statement creates a new String instance each time it is executed, and none\nof those object creations is necessary. The argument to the String constructor\n( \"bikini\" ) is itself a String instance, functionally identical to all of the objects\ncreated by the constructor. If this usage occurs in a loop or in a frequently invoked\nmethod, millions of String instances can be created needlessly.\nThe improved version is simply the following:\nString s = \"bikini\";\nThis version uses a single String instance, rather than creating a new one\neach time it is executed. Furthermore, it is guaranteed that the object will be\nreused by any other code running in the same virtual machine that happens to\ncontain the same string literal [JLS, 3.10.5].\nYou can often avoid creating unnecessary objects by using static factory meth-\nods (Item1) in preference to constructors on immutable classes that provide both.\nFor example, the factory method Boolean.valueOf(String) is preferable to the\nconstructor Boolean(String) , which was deprecated in Java 9. The constructor\nmust create a new object each time it’s called, while the factory method is never\nrequired to do so and won’t in practice. In addition to reusing immutable objects,\nyou can also reuse mutable objects if you know they won’t be modified.\nSome object creations are much more expensive than others. If you’re going\nto need such an “expensive object” repeatedly, it may be advisable to cache it for\nreuse. Unfortunately, it’s not always obvious when you’re creating such an object.\nSuppose you want to write a method to determine whether a string is a valid\nRoman numeral. Here’s the easiest way to do this using a regular expression:\n// Performance can be greatly improved!\nstatic boolean isRomanNumeral(String s) {\nreturn s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\"\n+ \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");\n}\n"
  },
  {
    "title": "ITEM 6: AVOID CREATING UNNECESSARY OBJECTS 23",
    "content": "The problem with this implementation is that it relies on the String.matches\nmethod. While String.matches is the easiest way to check if a string matches\na regular expression, it’s not suitable for repeated use in performance-critical\nsituations. The problem is that it internally creates a Pattern instance for the\nregular expression and uses it only once, after which it becomes eligible for\ngarbage collection. Creating a Pattern instance is expensive because it requires\ncompiling the regular expression into a finite state machine.\nTo improve the performance, explicitly compile the regular expression into a\nPattern instance (which is immutable) as part of class initialization, cache it, and\nreuse the same instance for every invocation of the isRomanNumeral method:\n// Reusing expensive object for improved performance\npublic class RomanNumerals {\nprivate static final Pattern ROMAN = Pattern.compile(\n\"^(?=.)M*(C[MD]|D?C{0,3})\"\n+ \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");\nstatic boolean isRomanNumeral(String s) {\nreturn ROMAN.matcher(s).matches();\n}\n}\nThe improved version of isRomanNumeral provides significant performance\ngains if invoked frequently. On my machine, the original version takes 1.1 µs on\nan 8-character input string, while the improved version takes 0.17 µs, which is 6.5\ntimes faster. Not only is the performance improved, but arguably, so is clarity.\nMaking a static final field for the otherwise invisible Pattern instance allows us\nto give it a name, which is far more readable than the regular expression itself.\nIf the class containing the improved version of the isRomanNumeral method is\ninitialized but the method is never invoked, the field ROMAN will be initialized\nneedlessly. It would be possible to eliminate the initialization by lazily initializing\nthe field (Item83) the first time the isRomanNumeral method is invoked, but this\nis not recommended. As is often the case with lazy initialization, it would compli-\ncate the implementation with no measurable performance improvement (Item67).\nWhen an object is immutable, it is obvious it can be reused safely, but there\nare other situations where it is far less obvious, even counterintuitive. Consider the\ncase of adapters [Gamma95] , also known as views . An adapter is an object that\ndelegates to a backing object, providing an alternative interface. Because an\nadapter has no state beyond that of its backing object, there’s no need to create\nmore than one instance of a given adapter to a given object.\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 24",
    "content": "For example, the keySet method of the Map interface returns a Set view of the\nMap object, consisting of all the keys in the map. Naively, it would seem that every\ncall to keySet would have to create a new Set instance, but every call to keySet\non a given Map object may return the same Set instance. Although the returned Set\ninstance is typically mutable, all of the returned objects are functionally identical:\nwhen one of the returned objects changes, so do all the others, because they’re all\nbacked by the same Map instance. While it is largely harmless to create multiple\ninstances of the keySet view object, it is unnecessary and has no benefits.\nAnother way to create unnecessary objects is autoboxing , which allows the\nprogrammer to mix primitive and boxed primitive types, boxing and unboxing\nautomatically as needed. Autoboxing blurs but does not erase the distinction\nbetween primitive and boxed primitive types. There are subtle semantic distinc-\ntions and not-so-subtle performance differences (Item61). Consider the following\nmethod, which calculates the sum of all the positive int values. To do this, the\nprogram has to use long arithmetic because an int is not big enough to hold the\nsum of all the positive int values:\n// Hideously slow! Can you spot the object creation?\nprivate static long sum() {\nLong sum = 0L;\nfor (long i = 0; i <= Integer.MAX_VALUE; i++)\nsum += i;\nreturn sum;\n}\nThis program gets the right answer, but it is much slower than it should be,\ndue to a one-character typographical error. The variable sum is declared as a Long\ninstead of a long , which means that the program constructs about 2 31 unnecessary\nLong instances (roughly one for each time the long i is added to the Long sum ).\nChanging the declaration of sum from Long to long reduces the runtime from 6.3\nseconds to 0.59 seconds on my machine. The lesson is clear: prefer primitives to\nThis item should not be misconstrued to imply that object creation is expen-\nsive and should be avoided. On the contrary, the creation and reclamation of small\nobjects whose constructors do little explicit work is cheap, especially on modern\nJVM implementations. Creating additional objects to enhance the clarity, simplic-\nity, or power of a program is generally a good thing.\nConversely, avoiding object creation by maintaining your own object pool is a\nbad idea unless the objects in the pool are extremely heavyweight. The classic\n"
  },
  {
    "title": "ITEM 6: AVOID CREATING UNNECESSARY OBJECTS 25",
    "content": "example of an object that does justify an object pool is a database connection. The\ncost of establishing the connection is sufficiently high that it makes sense to reuse\nthese objects. Generally speaking, however, maintaining your own object pools\nclutters your code, increases memory footprint, and harms performance. Modern\nJVM implementations have highly optimized garbage collectors that easily out-\nperform such object pools on lightweight objects.\nThe counterpoint to this item is Item50 on defensive copying . The present\nitem says, “Don’t create a new object when you should reuse an existing one,”\nwhile Item50 says, “Don’t reuse an existing object when you should create a new\none.” Note that the penalty for reusing an object when defensive copying is called\nfor is far greater than the penalty for needlessly creating a duplicate object. Failing\nto make defensive copies where required can lead to insidious bugs and security\nholes; creating objects unnecessarily merely affects style and performance.\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 26",
    "content": "Item 7: Eliminate obsolete object references\nIf you switched from a language with manual memory management, such as C or\nC++, to a garbage-collected language such as Java, your job as a programmer was\nmade much easier by the fact that your objects are automatically reclaimed when\nyou’re through with them. It seems almost like magic when you first experience it.\nIt can easily lead to the impression that you don’t have to think about memory\nmanagement, but this isn’t quite true.\nConsider the following simple stack implementation:\n// Can you spot the \"memory leak\"?\npublic class Stack {\nprivate Object[] elements;\nprivate int size = 0;\nprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\npublic Stack() {\nelements = new Object[DEFAULT_INITIAL_CAPACITY];\n}\npublic void push(Object e) {\nensureCapacity();\nelements[size++] = e;\n}\npublic Object pop() {\nif (size == 0)\nthrow new EmptyStackException();\nreturn elements[--size];\n}\n/**\n* Ensure space for at least one more element, roughly\n* doubling the capacity each time the array needs to grow.\n*/\nprivate void ensureCapacity() {\nif (elements.length == size)\nelements = Arrays.copyOf(elements, 2 * size + 1);\n}\n}\nThere’s nothing obviously wrong with this program (but see Item29 for a\ngeneric version). You could test it exhaustively, and it would pass every test with\nflying colors, but there’s a problem lurking. Loosely speaking, the program has a\n“memory leak,” which can silently manifest itself as reduced performance due to\n"
  },
  {
    "title": "ITEM 7: ELIMINATE OBSOLETE OBJECT REFERENCES 27",
    "content": "increased garbage collector activity or increased memory footprint. In extreme\ncases, such memory leaks can cause disk paging and even program failure with an\nOutOfMemoryError , but such failures are relatively rare.\nSo where is the memory leak? If a stack grows and then shrinks, the objects\nthat were popped off the stack will not be garbage collected, even if the program\nusing the stack has no more references to them. This is because the stack main-\ntains obsolete references to these objects. An obsolete reference is simply a refer-\nence that will never be dereferenced again. In this case, any references outside of\nthe “active portion” of the element array are obsolete. The active portion consists\nof the elements whose index is less than size .\nMemory leaks in garbage-collected languages (more properly known as unin-\ntentional object retentions ) are insidious. If an object reference is unintentionally\nretained, not only is that object excluded from garbage collection, but so too are\nany objects referenced by that object, and so on. Even if only a few object refer-\nences are unintentionally retained, many, many objects may be prevented from\nbeing garbage collected, with potentially large effects on performance.\nThe fix for this sort of problem is simple: null out references once they\nbecome obsolete. In the case of our Stack class, the reference to an item becomes\nobsolete as soon as it’s popped off the stack. The corrected version of the pop\nmethod looks like this:\npublic Object pop() {\nif (size == 0)\nthrow new EmptyStackException();\nObject result = elements[--size];\nelements[size] = null; // Eliminate obsolete reference\nreturn result;\n}\nAn added benefit of nulling out obsolete references is that if they are subse-\nquently dereferenced by mistake, the program will immediately fail with a\nNullPointerException , rather than quietly doing the wrong thing. It is always\nbeneficial to detect programming errors as quickly as possible.\nWhen programmers are first stung by this problem, they may overcompensate\nby nulling out every object reference as soon as the program is finished using it.\nThis is neither necessary nor desirable; it clutters up the program unnecessarily.\nNulling out object references should be the exception rather than the norm.\nThe best way to eliminate an obsolete reference is to let the variable that contained\nthe reference fall out of scope. This occurs naturally if you define each variable in\nthe narrowest possible scope (Item57).\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 28",
    "content": "So when should you null out a reference? What aspect of the Stack class\nmakes it susceptible to memory leaks? Simply put, it manages its own memory .\nThe storage pool consists of the elements of the elements array (the object refer-\nence cells, not the objects themselves). The elements in the active portion of the\narray (as defined earlier) are allocated , and those in the remainder of the array are\nfree . The garbage collector has no way of knowing this; to the garbage collector,\nall of the object references in the elements array are equally valid. Only the\nprogrammer knows that the inactive portion of the array is unimportant. The pro-\ngrammer effectively communicates this fact to the garbage collector by manually\nnulling out array elements as soon as they become part of the inactive portion.\nGenerally speaking, whenever a class manages its own memory, the pro-\ngrammer should be alert for memory leaks . Whenever an element is freed, any\nobject references contained in the element should be nulled out.\nAnother common source of memory leaks is caches. Once you put an\nobject reference into a cache, it’s easy to forget that it’s there and leave it in the\ncache long after it becomes irrelevant. There are several solutions to this problem.\nIf you’re lucky enough to implement a cache for which an entry is relevant exactly\nso long as there are references to its key outside of the cache, represent the cache\nas a WeakHashMap ; entries will be removed automatically after they become\nobsolete. Remember that WeakHashMap is useful only if the desired lifetime of\ncache entries is determined by external references to the key, not the value.\nMore commonly, the useful lifetime of a cache entry is less well defined, with\nentries becoming less valuable over time. Under these circumstances, the cache\nshould occasionally be cleansed of entries that have fallen into disuse. This can be\ndone by a background thread (perhaps a ScheduledThreadPoolExecutor ) or as a\nside effect of adding new entries to the cache. The LinkedHashMap class facilitates\nthe latter approach with its removeEldestEntry method. For more sophisticated\ncaches, you may need to use java.lang.ref directly.\nA third common source of memory leaks is listeners and other callbacks.\nIf you implement an API where clients register callbacks but don’t deregister them\nexplicitly, they will accumulate unless you take some action. One way to ensure\nthat callbacks are garbage collected promptly is to store only weak references to\nthem, for instance, by storing them only as keys in a WeakHashMap .\nBecause memory leaks typically do not manifest themselves as obvious\nfailures, they may remain present in a system for years. They are typically\ndiscovered only as a result of careful code inspection or with the aid of a\ndebugging tool known as a heap profiler . Therefore, it is very desirable to learn to\nanticipate problems like this before they occur and prevent them from happening.\n"
  },
  {
    "title": "ITEM 8: AVOID FINALIZERS AND CLEANERS 29",
    "content": "Item 8: Avoid finalizers and cleaners\nFinalizers are unpredictable, often dangerous, and generally unnecessary.\nTheir use can cause erratic behavior, poor performance, and portability problems.\nFinalizers have a few valid uses, which we’ll cover later in this item, but as a rule,\nyou should avoid them. As of Java 9, finalizers have been deprecated, but they are\nstill being used by the Java libraries. The Java 9 replacement for finalizers is\ncleaners . Cleaners are less dangerous than finalizers, but still unpredictable,\nslow, and generally unnecessary.\nC++ programmers are cautioned not to think of finalizers or cleaners as Java’s\nanalogue of C++ destructors. In C++, destructors are the normal way to reclaim\nthe resources associated with an object, a necessary counterpart to constructors. In\nJava, the garbage collector reclaims the storage associated with an object when it\nbecomes unreachable, requiring no special effort on the part of the programmer.\nC++ destructors are also used to reclaim other nonmemory resources. In Java, a\ntry -with-resources or try - finally block is used for this purpose (Item9).\nOne shortcoming of finalizers and cleaners is that there is no guarantee they’ll\nbe executed promptly [JLS, 12.6]. It can take arbitrarily long between the time\nthat an object becomes unreachable and the time its finalizer or cleaner runs. This\nmeans that you should never do anything time-critical in a finalizer or cleaner.\nFor example, it is a grave error to depend on a finalizer or cleaner to close files\nbecause open file descriptors are a limited resource. If many files are left open as a\nresult of the system’s tardiness in running finalizers or cleaners, a program may\nfail because it can no longer open files.\nThe promptness with which finalizers and cleaners are executed is primarily a\nfunction of the garbage collection algorithm, which varies widely across imple-\nmentations. The behavior of a program that depends on the promptness of finalizer\nor cleaner execution may likewise vary. It is entirely possible that such a program\nwill run perfectly on the JVM on which you test it and then fail miserably on the\none favored by your most important customer.\nTardy finalization is not just a theoretical problem. Providing a finalizer for a\nclass can arbitrarily delay reclamation of its instances. A colleague debugged a\nlong-running GUI application that was mysteriously dying with an\nOutOfMemoryError . Analysis revealed that at the time of its death, the application\nhad thousands of graphics objects on its finalizer queue just waiting to be finalized\nand reclaimed. Unfortunately, the finalizer thread was running at a lower priority\nthan another application thread, so objects weren’t getting finalized at the rate\nthey became eligible for finalization. The language specification makes no guar-\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 30",
    "content": "antees as to which thread will execute finalizers, so there is no portable way to\nprevent this sort of problem other than to refrain from using finalizers. Cleaners\nare a bit better than finalizers in this regard because class authors have control\nover their own cleaner threads, but cleaners still run in the background, under the\ncontrol of the garbage collector, so there can be no guarantee of prompt cleaning.\nNot only does the specification provide no guarantee that finalizers or\ncleaners will run promptly; it provides no guarantee that they’ll run at all. It is\nentirely possible, even likely, that a program terminates without running them on\nsome objects that are no longer reachable. As a consequence, you should never\ndepend on a finalizer or cleaner to update persistent state. For example,\ndepending on a finalizer or cleaner to release a persistent lock on a shared\nresource such as a database is a good way to bring your entire distributed system\nto a grinding halt.\nDon’t be seduced by the methods System.gc and System.runFinalization .\nThey may increase the odds of finalizers or cleaners getting executed, but they don’t\nguarantee it. Two methods once claimed to make this guarantee: System.run-\nFinalizersOnExit and its evil twin, Runtime.runFinalizersOnExit . These\nmethods are fatally flawed and have been deprecated for decades [ThreadStop].\nAnother problem with finalizers is that an uncaught exception thrown during\nfinalization is ignored, and finalization of that object terminates [JLS,12.6].\nUncaught exceptions can leave other objects in a corrupt state. If another thread\nattempts to use such a corrupted object, arbitrary nondeterministic behavior may\nresult. Normally, an uncaught exception will terminate the thread and print a stack\ntrace, but not if it occurs in a finalizer—it won’t even print a warning. Cleaners do\nnot have this problem because a library using a cleaner has control over its thread.\nThere is a severe performance penalty for using finalizers and cleaners. On\nmy machine, the time to create a simple AutoCloseable object, to close it using\ntry -with-resources, and to have the garbage collector reclaim it is about 12 ns.\nUsing a finalizer instead increases the time to 550 ns. In other words, it is about 50\ntimes slower to create and destroy objects with finalizers. This is primarily because\nfinalizers inhibit efficient garbage collection. Cleaners are comparable in speed to\nfinalizers if you use them to clean all instances of the class (about 500 ns per\ninstance on my machine), but cleaners are much faster if you use them only as a\nsafety net, as discussed below. Under these circumstances, creating, cleaning, and\ndestroying an object takes about 66 ns on my machine, which means you pay a\nfactor of five (not fifty) for the insurance of a safety net if you don’t use it.\nFinalizers have a serious security problem: they open your class up to\nfinalizer attacks. The idea behind a finalizer attack is simple: If an exception is\n"
  },
  {
    "title": "ITEM 8: AVOID FINALIZERS AND CLEANERS 31",
    "content": "thrown from a constructor or its serialization equivalents—the readObject and\nreadResolve methods (Chapter 12)—the finalizer of a malicious subclass can run\non the partially constructed object that should have “died on the vine.” This final-\nizer can record a reference to the object in a static field, preventing it from being\ngarbage collected. Once the malformed object has been recorded, it is a simple\nmatter to invoke arbitrary methods on this object that should never have been\nallowed to exist in the first place. Throwing an exception from a constructor\nshould be sufficient to prevent an object from coming into existence; in the\npresence of finalizers, it is not. Such attacks can have dire consequences. Final\nclasses are immune to finalizer attacks because no one can write a malicious\nsubclass of a final class. To protect nonfinal classes from finalizer attacks,\nwrite a final finalize method that does nothing.\nSo what should you do instead of writing a finalizer or cleaner for a class\nwhose objects encapsulate resources that require termination, such as files or\nthreads? Just have your class implement AutoCloseable , and require its clients\nto invoke the close method on each instance when it is no longer needed,\ntypically using try -with-resources to ensure termination even in the face of\nexceptions (Item9). One detail worth mentioning is that the instance must keep\ntrack of whether it has been closed: the close method must record in a field that\nthe object is no longer valid, and other methods must check this field and throw an\nIllegalStateException if they are called after the object has been closed.\nSo what, if anything, are cleaners and finalizers good for? They have perhaps\ntwo legitimate uses. One is to act as a safety net in case the owner of a resource\nneglects to call its close method. While there’s no guarantee that the cleaner or\nfinalizer will run promptly (or at all), it is better to free the resource late than never\nif the client fails to do so. If you’re considering writing such a safety-net finalizer,\nthink long and hard about whether the protection is worth the cost. Some Java\nlibrary classes, such as FileInputStream , FileOutputStream , ThreadPoolEx-\necutor , and java.sql.Connection , have finalizers that serve as safety nets.\nA second legitimate use of cleaners concerns objects with native peers . A\nnative peer is a native (non-Java) object to which a normal object delegates via\nnative methods. Because a native peer is not a normal object, the garbage collector\ndoesn’t know about it and can’t reclaim it when its Java peer is reclaimed. A\ncleaner or finalizer may be an appropriate vehicle for this task, assuming the\nperformance is acceptable and the native peer holds no critical resources. If the\nperformance is unacceptable or the native peer holds resources that must be\nreclaimed promptly, the class should have a close method, as described earlier.\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 32",
    "content": "Cleaners are a bit tricky to use. Below is a simple Room class demonstrating\nthe facility. Let’s assume that rooms must be cleaned before they are reclaimed.\nThe Room class implements AutoCloseable ; the fact that its automatic cleaning\nsafety net uses a cleaner is merely an implementation detail. Unlike finalizers,\ncleaners do not pollute a class’s public API:\n// An autocloseable class using a cleaner as a safety net\npublic class Room implements AutoCloseable {\nprivate static final Cleaner cleaner = Cleaner.create();\n// Resource that requires cleaning. Must not refer to Room!\nprivate static class State implements Runnable {\nint numJunkPiles; // Number of junk piles in this room\nState(int numJunkPiles) {\nthis.numJunkPiles = numJunkPiles;\n}\n// Invoked by close method or cleaner\n@Override public void run() {\nSystem.out.println(\"Cleaning room\");\nnumJunkPiles = 0;\n}\n}\n// The state of this room, shared with our cleanable\nprivate final State state;\n// Our cleanable. Cleans the room when it’s eligible for gc\nprivate final Cleaner.Cleanable cleanable;\npublic Room(int numJunkPiles) {\nstate = new State(numJunkPiles);\ncleanable = cleaner.register(this, state);\n}\n@Override public void close() {\ncleanable.clean();\n}\n}\nThe static nested State class holds the resources that are required by the\ncleaner to clean the room. In this case, it is simply the numJunkPiles field, which\nrepresents the amount of mess in the room. More realistically, it might be a final\nlong that contains a pointer to a native peer. State implements Runnable , and its\nrun method is called at most once, by the Cleanable that we get when we register\nour State instance with our cleaner in the Room constructor. The call to the run\nmethod will be triggered by one of two things: Usually it is triggered by a call to\n"
  },
  {
    "title": "ITEM 8: AVOID FINALIZERS AND CLEANERS 33",
    "content": "Room ’s close method calling Cleanable ’s clean method. If the client fails to call\nthe close method by the time a Room instance is eligible for garbage collection,\nthe cleaner will (hopefully) call State ’s run method.\nIt is critical that a State instance does not refer to its Room instance. If it did, it\nwould create a circularity that would prevent the Room instance from becoming\neligible for garbage collection (and from being automatically cleaned). Therefore,\nState must be a static nested class because nonstatic nested classes contain\nreferences to their enclosing instances (Item24). It is similarly inadvisable to use\na lambda because they can easily capture references to enclosing objects.\nAs we said earlier, Room ’s cleaner is used only as a safety net. If clients\nsurround all Room instantiations in try -with-resource blocks, automatic cleaning\nwill never be required. This well-behaved client demonstrates that behavior:\npublic class Adult {\npublic static void main(String[] args) {\ntry (Room myRoom = new Room(7)) {\nSystem.out.println(\"Goodbye\");\n}\n}\n}\nAs you’d expect, running the Adult program prints Goodbye , followed by Clean-\ning room . But what about this ill-behaved program, which never cleans its room?\npublic class Teenager {\npublic static void main(String[] args) {\nnew Room(99);\nSystem.out.println(\"Peace out\");\n}\n}\nYou might expect it to print Peace out , followed by Cleaning room , but on my\nmachine, it never prints Cleaning room ; it just exits. This is the unpredictability\nwe spoke of earlier. The Cleaner spec says, “The behavior of cleaners during Sys-\ntem.exit is implementation specific. No guarantees are made relating to whether\ncleaning actions are invoked or not.” While the spec does not say it, the same holds\ntrue for normal program exit. On my machine, adding the line System.gc() to\nTeenager ’s main method is enough to make it print Cleaning room prior to exit,\nbut there’s no guarantee that you’ll see the same behavior on your machine.\nIn summary, don’t use cleaners, or in releases prior to Java 9, finalizers,\nexcept as a safety net or to terminate noncritical native resources. Even then,\nbeware the indeterminacy and performance consequences.\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 34",
    "content": "Item 9: Prefer try -with-resources to try - finally\nThe Java libraries include many resources that must be closed manually by invok-\ning a close method. Examples include InputStream , OutputStream , and\njava.sql.Connection . Closing resources is often overlooked by clients, with\npredictably dire performance consequences. While many of these resources use\nfinalizers as a safety net, finalizers don’t work very well (Item8).\nHistorically, a try - finally statement was the best way to guarantee that a\nresource would be closed properly, even in the face of an exception or return:\n// try-finally - No longer the best way to close resources!\nstatic String firstLineOfFile(String path) throws IOException {\nBufferedReader br = new BufferedReader(new FileReader(path));\ntry {\nreturn br.readLine();\n} finally {\nbr.close();\n}\n}\nThis may not look bad, but it gets worse when you add a second resource:\n// try-finally is ugly when used with more than one resource!\nstatic void copy(String src, String dst) throws IOException {\nInputStream in = new FileInputStream(src);\ntry {\nOutputStream out = new FileOutputStream(dst);\ntry {\nbyte[] buf = new byte[BUFFER_SIZE];\nint n;\nwhile ((n = in.read(buf)) >= 0)\nout.write(buf, 0, n);\n} finally {\nout.close();\n}\n} finally {\nin.close();\n}\n}\nIt may be hard to believe, but even good programmers got this wrong most of\nthe time. For starters, I got it wrong on page 88 of Java Puzzlers [Bloch05], and\nno one noticed for years. In fact, two-thirds of the uses of the close method in the\nJava libraries were wrong in 2007.\n"
  },
  {
    "title": "ITEM 9: PREFER TRY-WITH-RESOURCES TO TRY-FINALLY 35",
    "content": "Even the correct code for closing resources with try - finally statements, as\nillustrated in the previous two code examples, has a subtle deficiency. The code in\nboth the try block and the finally block is capable of throwing exceptions. For\nexample, in the firstLineOfFile method, the call to readLine could throw an\nexception due to a failure in the underlying physical device, and the call to close\ncould then fail for the same reason. Under these circumstances, the second\nexception completely obliterates the first one. There is no record of the first\nexception in the exception stack trace, which can greatly complicate debugging in\nreal systems—usually it’s the first exception that you want to see in order to\ndiagnose the problem. While it is possible to write code to suppress the second\nexception in favor of the first, virtually no one did because it’s just too verbose.\nAll of these problems were solved in one fell swoop when Java 7 introduced\nthe try -with-resources statement [JLS, 14.20.3]. To be usable with this construct,\na resource must implement the AutoCloseable interface, which consists of a\nsingle void -returning close method. Many classes and interfaces in the Java\nlibraries and in third-party libraries now implement or extend AutoCloseable . If\nyou write a class that represents a resource that must be closed, your class should\nimplement AutoCloseable too.\nHere’s how our first example looks using try -with-resources:\n// try-with-resources - the the best way to close resources!\nstatic String firstLineOfFile(String path) throws IOException {\ntry (BufferedReader br = new BufferedReader(\nnew FileReader(path))) {\nreturn br.readLine();\n}\n}\nAnd here’s how our second example looks using try -with-resources:\n// try-with-resources on multiple resources - short and sweet\nstatic void copy(String src, String dst) throws IOException {\ntry (InputStream in = new FileInputStream(src);\nOutputStream out = new FileOutputStream(dst)) {\nbyte[] buf = new byte[BUFFER_SIZE];\nint n;\nwhile ((n = in.read(buf)) >= 0)\nout.write(buf, 0, n);\n}\n}\nNot only are the try -with-resources versions shorter and more readable than the\noriginals, but they provide far better diagnostics. Consider the firstLineOfFile\n"
  },
  {
    "title": "CHAPTER2 CREATING AND DESTROYING OBJECTS 36",
    "content": "method. If exceptions are thrown by both the readLine call and the (invisible)\nclose , the latter exception is suppressed in favor of the former. In fact, multiple\nexceptions may be suppressed in order to preserve the exception that you actually\nwant to see. These suppressed exceptions are not merely discarded; they are\nprinted in the stack trace with a notation saying that they were suppressed. You\ncan also access them programmatically with the getSuppressed method, which\nwas added to Throwable in Java 7.\nYou can put catch clauses on try -with-resources statements, just as you can\non regular try - finally statements. This allows you to handle exceptions without\nsullying your code with another layer of nesting. As a slightly contrived example,\nhere’s a version our firstLineOfFile method that does not throw exceptions, but\ntakes a default value to return if it can’t open the file or read from it:\n// try-with-resources with a catch clause\nstatic String firstLineOfFile(String path, String defaultVal) {\ntry (BufferedReader br = new BufferedReader(\nnew FileReader(path))) {\nreturn br.readLine();\n} catch (IOException e) {\nreturn defaultVal;\n}\n}\nThe lesson is clear: Always use try -with-resources in preference to try -\nfinally when working with resources that must be closed. The resulting code is\nshorter and clearer, and the exceptions that it generates are more useful. The try -\nwith-resources statement makes it easy to write correct code using resources that\nmust be closed, which was practically impossible using try - finally .\n"
  }
]